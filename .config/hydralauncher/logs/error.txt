[2025-12-08 09:33:11.875] [error] (main)         Failed to connect WS: UserNotLoggedInError: user not logged in
    at HydraApi.validateOptions (file:///opt/Hydra/resources/app.asar/out/main/index.js:5990:37)
    at HydraApi.post (file:///opt/Hydra/resources/app.asar/out/main/index.js:6010:16)
    at WSClient.connect (file:///opt/Hydra/resources/app.asar/out/main/index.js:5691:40)
    at file:///opt/Hydra/resources/app.asar/out/main/index.js:30529:18
    at async loadState (file:///opt/Hydra/resources/app.asar/out/main/index.js:30523:5)
    at async file:///opt/Hydra/resources/app.asar/out/main/index.js:30634:5
[2025-12-08 09:33:12.878] [error] (main)         Failed to connect WS: UserNotLoggedInError: user not logged in
    at HydraApi.validateOptions (file:///opt/Hydra/resources/app.asar/out/main/index.js:5990:37)
    at HydraApi.post (file:///opt/Hydra/resources/app.asar/out/main/index.js:6010:16)
    at WSClient.connect (file:///opt/Hydra/resources/app.asar/out/main/index.js:5691:40)
    at Timeout._onTimeout (file:///opt/Hydra/resources/app.asar/out/main/index.js:5739:20)
    at listOnTimeout (node:internal/timers:588:17)
    at process.processTimers (node:internal/timers:523:7)
[2025-12-08 09:35:09.197] [error] (main)         Error handling deep link --allow-file-access-from-files TypeError: Invalid URL
    at new URL (node:internal/url:825:25)
    at handleDeepLinkPath (file:///opt/Hydra/resources/app.asar/out/main/index.js:30651:21)
    at App.<anonymous> (file:///opt/Hydra/resources/app.asar/out/main/index.js:30682:5)
    at App.emit (node:events:519:28)
[2025-12-08 09:35:09.381] [error]                Unhandled rejection Error: Database is not open
    at assertOpen (/opt/Hydra/resources/app.asar/node_modules/abstract-level/abstract-level.js:878:11)
    at ClassicLevel.get (/opt/Hydra/resources/app.asar/node_modules/abstract-level/abstract-level.js:321:5)
    at loadState (file:///opt/Hydra/resources/app.asar/out/main/index.js:30505:38)
    at process.processTicksAndRejections (node:internal/process/task_queues:105:5)
    at async file:///opt/Hydra/resources/app.asar/out/main/index.js:30634:5
[2025-12-08 09:35:42.430] [error] (main)         Failed to get default wine prefix selection path Error: ENOENT: no such file or directory, realpath '/home/onicuto/.local/share/Steam/steamapps/compatdata'
[2025-12-08 09:36:19.899] [error] (main)         Error on getSteamAppDetails { message: 'read ECONNRESET', code: 'ECONNRESET', name: 'Error' }
[2025-12-08 09:36:19.900] [error] (main)         Error on getSteamAppDetails { message: 'read ECONNRESET', code: 'ECONNRESET', name: 'Error' }
[2025-12-08 09:36:23.995] [error] (main)         Error on getSteamAppDetails { message: 'read ECONNRESET', code: 'ECONNRESET', name: 'Error' }
[2025-12-08 09:36:23.996] [error] (main)         Error on getSteamAppDetails { message: 'read ECONNRESET', code: 'ECONNRESET', name: 'Error' }
[2025-12-08 09:36:23.997] [error] (main)         Error on getSteamAppDetails { message: 'read ECONNRESET', code: 'ECONNRESET', name: 'Error' }
[2025-12-08 09:36:23.997] [error] (main)         Error on getSteamAppDetails { message: 'read ECONNRESET', code: 'ECONNRESET', name: 'Error' }
[2025-12-08 09:36:44.474] [error] (main)         Error on getSteamAppDetails { message: 'read ECONNRESET', code: 'ECONNRESET', name: 'Error' }
[2025-12-08 09:36:44.477] [error] (main)         Error on getSteamAppDetails { message: 'read ECONNRESET', code: 'ECONNRESET', name: 'Error' }
[2025-12-08 09:37:09.054] [error] (main)         Error on getSteamAppDetails { message: 'read ECONNRESET', code: 'ECONNRESET', name: 'Error' }
[2025-12-08 09:37:09.055] [error] (main)         Error on getSteamAppDetails { message: 'read ECONNRESET', code: 'ECONNRESET', name: 'Error' }
[2025-12-08 09:37:13.146] [error] (main)         Error on getSteamAppDetails { message: 'read ECONNRESET', code: 'ECONNRESET', name: 'Error' }
[2025-12-08 09:37:17.242] [error] (main)         Error on getSteamAppDetails { message: 'read ECONNRESET', code: 'ECONNRESET', name: 'Error' }
[2025-12-08 09:37:17.244] [error] (main)         Error on getSteamAppDetails { message: 'read ECONNRESET', code: 'ECONNRESET', name: 'Error' }
[2025-12-08 09:37:17.244] [error] (main)         Error on getSteamAppDetails { message: 'read ECONNRESET', code: 'ECONNRESET', name: 'Error' }
[2025-12-08 09:37:17.245] [error] (main)         Error on getSteamAppDetails { message: 'read ECONNRESET', code: 'ECONNRESET', name: 'Error' }
[2025-12-08 09:37:17.245] [error] (main)         Error on getSteamAppDetails { message: 'read ECONNRESET', code: 'ECONNRESET', name: 'Error' }
[2025-12-08 09:37:25.437] [error] (main)         Error on getSteamAppDetails { message: 'read ECONNRESET', code: 'ECONNRESET', name: 'Error' }
[2025-12-08 09:37:25.437] [error] (main)         Error on getSteamAppDetails { message: 'read ECONNRESET', code: 'ECONNRESET', name: 'Error' }
[2025-12-08 09:37:25.438] [error] (main)         Error on getSteamAppDetails { message: 'read ECONNRESET', code: 'ECONNRESET', name: 'Error' }
[2025-12-08 09:37:25.438] [error] (main)         Error on getSteamAppDetails { message: 'read ECONNRESET', code: 'ECONNRESET', name: 'Error' }
[2025-12-08 09:38:14.588] [error] (main)         Error on getSteamAppDetails { message: 'read ECONNRESET', code: 'ECONNRESET', name: 'Error' }
[2025-12-08 09:38:18.687] [error] (main)         Error on getSteamAppDetails { message: 'read ECONNRESET', code: 'ECONNRESET', name: 'Error' }
[2025-12-08 09:38:30.971] [error] (main)         Error on getSteamAppDetails { message: 'read ECONNRESET', code: 'ECONNRESET', name: 'Error' }
[2025-12-08 09:38:30.973] [error] (main)         Error on getSteamAppDetails { message: 'read ECONNRESET', code: 'ECONNRESET', name: 'Error' }
[2025-12-08 09:38:30.973] [error] (main)         Error on getSteamAppDetails { message: 'read ECONNRESET', code: 'ECONNRESET', name: 'Error' }
[2025-12-08 09:38:30.974] [error] (main)         Error on getSteamAppDetails { message: 'read ECONNRESET', code: 'ECONNRESET', name: 'Error' }
[2025-12-08 09:38:39.163] [error] (main)         Error on getSteamAppDetails { message: 'read ECONNRESET', code: 'ECONNRESET', name: 'Error' }
[2025-12-08 09:38:39.164] [error] (main)         Error on getSteamAppDetails { message: 'read ECONNRESET', code: 'ECONNRESET', name: 'Error' }
[2025-12-08 09:38:39.164] [error] (main)         Error on getSteamAppDetails { message: 'read ECONNRESET', code: 'ECONNRESET', name: 'Error' }
[2025-12-08 09:38:39.165] [error] (main)         Error on getSteamAppDetails { message: 'read ECONNRESET', code: 'ECONNRESET', name: 'Error' }
[2025-12-08 09:38:39.165] [error] (main)         Error on getSteamAppDetails { message: 'read ECONNRESET', code: 'ECONNRESET', name: 'Error' }
[2025-12-08 09:38:39.165] [error] (main)         Error on getSteamAppDetails { message: 'read ECONNRESET', code: 'ECONNRESET', name: 'Error' }
[2025-12-08 09:38:39.166] [error] (main)         Error on getSteamAppDetails { message: 'read ECONNRESET', code: 'ECONNRESET', name: 'Error' }
[2025-12-08 09:38:39.166] [error] (main)         Error on getSteamAppDetails { message: 'read ECONNRESET', code: 'ECONNRESET', name: 'Error' }
[2025-12-08 09:39:11.930] [error] (main)         Error on getSteamAppDetails { message: 'read ECONNRESET', code: 'ECONNRESET', name: 'Error' }
[2025-12-08 09:39:11.931] [error] (main)         Error on getSteamAppDetails { message: 'read ECONNRESET', code: 'ECONNRESET', name: 'Error' }
[2025-12-08 09:39:11.932] [error] (main)         Error on getSteamAppDetails { message: 'read ECONNRESET', code: 'ECONNRESET', name: 'Error' }
[2025-12-08 09:39:11.933] [error] (main)         Error on getSteamAppDetails { message: 'read ECONNRESET', code: 'ECONNRESET', name: 'Error' }
[2025-12-08 09:39:11.934] [error] (main)         Error on getSteamAppDetails { message: 'read ECONNRESET', code: 'ECONNRESET', name: 'Error' }
[2025-12-08 09:39:11.934] [error] (main)         Error on getSteamAppDetails { message: 'read ECONNRESET', code: 'ECONNRESET', name: 'Error' }
[2025-12-08 09:39:11.935] [error] (main)         Error on getSteamAppDetails { message: 'read ECONNRESET', code: 'ECONNRESET', name: 'Error' }
[2025-12-08 09:40:23.586] [error] (main)         Error on getSteamAppDetails { message: 'read ETIMEDOUT', code: 'ETIMEDOUT', name: 'Error' }
[2025-12-08 09:56:45.898] [error] (main)         Failed to connect WS: {
  message: 'Error',
  name: 'AggregateError',
  stack: 'AggregateError: Error\n' +
    '    at AxiosError.from (file:///opt/Hydra/resources/app.asar/node_modules/axios/lib/core/AxiosError.js:96:14)\n' +
    '    at RedirectableRequest.handleRequestError (file:///opt/Hydra/resources/app.asar/node_modules/axios/lib/adapters/http.js:638:25)\n' +
    '    at RedirectableRequest.emit (node:events:519:28)\n' +
    '    at eventHandlers.<computed> (/opt/Hydra/resources/app.asar/node_modules/follow-redirects/index.js:49:24)\n' +
    '    at ClientRequest.emit (node:events:519:28)\n' +
    '    at emitErrorEvent (node:_http_client:105:11)\n' +
    '    at TLSSocket.socketErrorListener (node:_http_client:518:5)\n' +
    '    at TLSSocket.emit (node:events:519:28)\n' +
    '    at emitErrorNT (node:internal/streams/destroy:170:8)\n' +
    '    at emitErrorCloseNT (node:internal/streams/destroy:129:3)\n' +
    '    at Axios.request (file:///opt/Hydra/resources/app.asar/node_modules/axios/lib/core/Axios.js:45:41)\n' +
    '    at process.processTicksAndRejections (node:internal/process/task_queues:105:5)\n' +
    '    at async WSClient.connect (file:///opt/Hydra/resources/app.asar/out/main/index.js:5691:25)\n' +
    '    at async Timeout._onTimeout (file:///opt/Hydra/resources/app.asar/out/main/index.js:5739:9)',
  config: {
    transitional: {
      silentJSONParsing: true,
      forcedJSONParsing: true,
      clarifyTimeoutError: false
    },
    adapter: [ 'xhr', 'http', 'fetch' ],
    transformRequest: [
      '[function] function transformRequest(data, headers) {\n' +
        "    const contentType = headers.getContentType() || '';\n" +
        "    const hasJSONContentType = contentType.indexOf('application/json') > -1;\n" +
        '    const isObjectPayload = utils.isObject(data);\n' +
        '\n' +
        '    if (isObjectPayload && utils.isHTMLForm(data)) {\n' +
        '      data = new FormData(data);\n' +
        '    }\n' +
        '\n' +
        '    const isFormData = utils.isFormData(data);\n' +
        '\n' +
        '    if (isFormData) {\n' +
        '      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;\n' +
        '    }\n' +
        '\n' +
        '    if (utils.isArrayBuffer(data) ||\n' +
        '      utils.isBuffer(data) ||\n' +
        '      utils.isStream(data) ||\n' +
        '      utils.isFile(data) ||\n' +
        '      utils.isBlob(data) ||\n' +
        '      utils.isReadableStream(data)\n' +
        '    ) {\n' +
        '      return data;\n' +
        '    }\n' +
        '    if (utils.isArrayBufferView(data)) {\n' +
        '      return data.buffer;\n' +
        '    }\n' +
        '    if (utils.isURLSearchParams(data)) {\n' +
        "      headers.setContentType('application/x-www-form-urlencoded;charset=utf-8', false);\n" +
        '      return data.toString();\n' +
        '    }\n' +
        '\n' +
        '    let isFileList;\n' +
        '\n' +
        '    if (isObjectPayload) {\n' +
        "      if (contentType.indexOf('application/x-www-form-urlencoded') > -1) {\n" +
        '        return toURLEncodedForm(data, this.formSerializer).toString();\n' +
        '      }\n' +
        '\n' +
        "      if ((isFileList = utils.isFileList(data)) || contentType.indexOf('multipart/form-data') > -1) {\n" +
        '        const _FormData = this.env && this.env.FormData;\n' +
        '\n' +
        '        return toFormData(\n' +
        "          isFileList ? {'files[]': data} : data,\n" +
        '          _FormData && new _FormData(),\n' +
        '          this.formSerializer\n' +
        '        );\n' +
        '      }\n' +
        '    }\n' +
        '\n' +
        '    if (isObjectPayload || hasJSONContentType ) {\n' +
        "      headers.setContentType('application/json', false);\n" +
        '      return stringifySafely(data);\n' +
        '    }\n' +
        '\n' +
        '    return data;\n' +
        '  }'
    ],
    transformResponse: [
      '[function] function transformResponse(data) {\n' +
        '    const transitional = this.transitional || defaults.transitional;\n' +
        '    const forcedJSONParsing = transitional && transitional.forcedJSONParsing;\n' +
        "    const JSONRequested = this.responseType === 'json';\n" +
        '\n' +
        '    if (utils.isResponse(data) || utils.isReadableStream(data)) {\n' +
        '      return data;\n' +
        '    }\n' +
        '\n' +
        '    if (data && utils.isString(data) && ((forcedJSONParsing && !this.responseType) || JSONRequested)) {\n' +
        '      const silentJSONParsing = transitional && transitional.silentJSONParsing;\n' +
        '      const strictJSONParsing = !silentJSONParsing && JSONRequested;\n' +
        '\n' +
        '      try {\n' +
        '        return JSON.parse(data, this.parseReviver);\n' +
        '      } catch (e) {\n' +
        '        if (strictJSONParsing) {\n' +
        "          if (e.name === 'SyntaxError') {\n" +
        '            throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);\n' +
        '          }\n' +
        '          throw e;\n' +
        '        }\n' +
        '      }\n' +
        '    }\n' +
        '\n' +
        '    return data;\n' +
        '  }'
    ],
    timeout: 0,
    xsrfCookieName: 'XSRF-TOKEN',
    xsrfHeaderName: 'X-XSRF-TOKEN',
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
      FormData: '[function] function FormData(options) {\n' +
        '  if (!(this instanceof FormData)) {\n' +
        '    return new FormData(options);\n' +
        '  }\n' +
        '\n' +
        '  this._overheadLength = 0;\n' +
        '  this._valueLength = 0;\n' +
        '  this._valuesToMeasure = [];\n' +
        '\n' +
        '  CombinedStream.call(this);\n' +
        '\n' +
        '  options = options || {}; // eslint-disable-line no-param-reassign\n' +
        '  for (var option in options) { // eslint-disable-line no-restricted-syntax\n' +
        '    this[option] = options[option];\n' +
        '  }\n' +
        '}',
      Blob: '[function] class Blob {\n' +
        '  /**\n' +
        '   * @typedef {string|ArrayBuffer|ArrayBufferView|Blob} SourcePart\n' +
        '   */\n' +
        '\n' +
        '  /**\n' +
        '   * @param {SourcePart[]} [sources]\n' +
        '   * @param {{\n' +
        '   *   endings? : string,\n' +
        '   *   type? : string,\n' +
        '   * }} [options]\n' +
        '   * @constructs {Blob}\n' +
        '   */\n' +
        '  constructor(sources = [], options) {\n' +
        '    markTransferMode(this, true, false);\n' +
        '\n' +
        '    if (sources === null ||\n' +
        "        typeof sources[SymbolIterator] !== 'function' ||\n" +
        "        typeof sources === 'string') {\n" +
        "      throw new ERR_INVALID_ARG_TYPE('sources', 'a sequence', sources);\n" +
        '    }\n' +
        "    validateDictionary(options, 'options');\n" +
        '    let {\n' +
        "      type = '',\n" +
        "      endings = 'transparent',\n" +
        '    } = options ?? kEmptyObject;\n' +
        '\n' +
        '    endings = `${endings}`;\n' +
        "    if (endings !== 'transparent' && endings !== 'native')\n" +
        "      throw new ERR_INVALID_ARG_VALUE('options.endings', endings);\n" +
        '\n' +
        '    let length = 0;\n' +
        '    const sources_ = ArrayFrom(sources, (source) => {\n' +
        '      const { 0: len, 1: src } = getSource(source, endings);\n' +
        '      length += len;\n' +
        '      return src;\n' +
        '    });\n' +
        '\n' +
        '    if (length > kMaxLength)\n' +
        '      throw new ERR_BUFFER_TOO_LARGE(kMaxLength);\n' +
        '\n' +
        '    this[kHandle] = _createBlob(sources_, length);\n' +
        '    this[kLength] = length;\n' +
        '\n' +
        '    type = `${type}`;\n' +
        '    this[kType] = RegExpPrototypeExec(disallowedTypeCharacters, type) !== null ?\n' +
        "      '' : StringPrototypeToLowerCase(type);\n" +
        '  }\n' +
        '\n' +
        '  [kInspect](depth, options) {\n' +
        '    if (depth < 0)\n' +
        '      return this;\n' +
        '\n' +
        '    const opts = {\n' +
        '      ...options,\n' +
        '      depth: options.depth == null ? null : options.depth - 1,\n' +
        '    };\n' +
        '\n' +
        '    return `Blob ${inspect({\n' +
        '      size: this.size,\n' +
        '      type: this.type,\n' +
        '    }, opts)}`;\n' +
        '  }\n' +
        '\n' +
        '  [kClone]() {\n' +
        '    if (this[kNotCloneable]) {\n' +
        '      // We do not currently allow file-backed Blobs to be cloned or passed across\n' +
        '      // worker threads.\n' +
        "      throw new ERR_INVALID_STATE.TypeError('File-backed Blobs are not cloneable');\n" +
        '    }\n' +
        '    const handle = this[kHandle];\n' +
        '    const type = this[kType];\n' +
        '    const length = this[kLength];\n' +
        '    return {\n' +
        '      data: { handle, type, length },\n' +
        "      deserializeInfo: 'internal/blob:Blob',\n" +
        '    };\n' +
        '  }\n' +
        '\n' +
        '  [kDeserialize]({ handle, type, length }) {\n' +
        '    this[kHandle] = handle;\n' +
        '    this[kType] = type;\n' +
        '    this[kLength] = length;\n' +
        '  }\n' +
        '\n' +
        '  /**\n' +
        '   * @readonly\n' +
        '   * @type {string}\n' +
        '   */\n' +
        '  get type() {\n' +
        '    if (!isBlob(this))\n' +
        "      throw new ERR_INVALID_THIS('Blob');\n" +
        '    return this[kType];\n' +
        '  }\n' +
        '\n' +
        '  /**\n' +
        '   * @readonly\n' +
        '   * @type {number}\n' +
        '   */\n' +
        '  get size() {\n' +
        '    if (!isBlob(this))\n' +
        "      throw new ERR_INVALID_THIS('Blob');\n" +
        '    return this[kLength];\n' +
        '  }\n' +
        '\n' +
        '  /**\n' +
        '   * @param {number} [start]\n' +
        '   * @param {number} [end]\n' +
        '   * @param {string} [contentType]\n' +
        '   * @returns {Blob}\n' +
        '   */\n' +
        "  slice(start = 0, end = this[kLength], contentType = '') {\n" +
        '    if (!isBlob(this))\n' +
        "      throw new ERR_INVALID_THIS('Blob');\n" +
        '\n' +
        '    // Coerce values to int\n' +
        '    const opts = { __proto__: null, signed: true };\n' +
        "    start = convertToInt('start', start, 64, opts);\n" +
        "    end = convertToInt('end', end, 64, opts);\n" +
        '\n' +
        '    if (start < 0) {\n' +
        '      start = MathMax(this[kLength] + start, 0);\n' +
        '    } else {\n' +
        '      start = MathMin(start, this[kLength]);\n' +
        '    }\n' +
        '\n' +
        '    if (end < 0) {\n' +
        '      end = MathMax(this[kLength] + end, 0);\n' +
        '    } else {\n' +
        '      end = MathMin(end, this[kLength]);\n' +
        '    }\n' +
        '\n' +
        '    contentType = `${contentType}`;\n' +
        '    if (RegExpPrototypeExec(disallowedTypeCharacters, contentType) !== null) {\n' +
        "      contentType = '';\n" +
        '    } else {\n' +
        '      contentType = StringPrototypeToLowerCase(contentType);\n' +
        '    }\n' +
        '\n' +
        '    const span = MathMax(end - start, 0);\n' +
        '\n' +
        '    return createBlob(\n' +
        '      this[kHandle].slice(start, start + span),\n' +
        '      span,\n' +
        '      contentType);\n' +
        '  }\n' +
        '\n' +
        '  /**\n' +
        '   * @returns {Promise<ArrayBuffer>}\n' +
        '   */\n' +
        '  arrayBuffer() {\n' +
        '    if (!isBlob(this))\n' +
        "      return PromiseReject(new ERR_INVALID_THIS('Blob'));\n" +
        '\n' +
        '    return arrayBuffer(this);\n' +
        '  }\n' +
        '\n' +
        '  /**\n' +
        '   * @returns {Promise<string>}\n' +
        '   */\n' +
        '  text() {\n' +
        '    if (!isBlob(this))\n' +
        "      return PromiseReject(new ERR_INVALID_THIS('Blob'));\n" +
        '\n' +
        '    dec ??= new TextDecoder();\n' +
        '\n' +
        '    return PromisePrototypeThen(\n' +
        '      arrayBuffer(this),\n' +
        '      (buffer) => dec.decode(buffer));\n' +
        '  }\n' +
        '\n' +
        '  /**\n' +
        '   * @returns {Promise<Uint8Array>}\n' +
        '   */\n' +
        '  bytes() {\n' +
        '    if (!isBlob(this))\n' +
        "      return PromiseReject(new ERR_INVALID_THIS('Blob'));\n" +
        '\n' +
        '    return PromisePrototypeThen(\n' +
        '      arrayBuffer(this),\n' +
        '      (buffer) => new Uint8Array(buffer));\n' +
        '  }\n' +
        '\n' +
        '  /**\n' +
        '   * @returns {ReadableStream}\n' +
        '   */\n' +
        '  stream() {\n' +
        '    if (!isBlob(this))\n' +
        "      throw new ERR_INVALID_THIS('Blob');\n" +
        '\n' +
        '    const reader = this[kHandle].getReader();\n' +
        '    return new lazyReadableStream({\n' +
        "      type: 'bytes',\n" +
        '      start(c) {\n' +
        '        // There really should only be one read at a time so using an\n' +
        '        // array here is purely defensive.\n' +
        '        this.pendingPulls = [];\n' +
        '      },\n' +
        '      pull(c) {\n' +
        '        const { promise, resolve, reject } = PromiseWithResolvers();\n' +
        '        this.pendingPulls.push({ resolve, reject });\n' +
        '        const readNext = () => {\n' +
        '          reader.pull((status, buffer) => {\n' +
        '            // If pendingPulls is empty here, the stream had to have\n' +
        "            // been canceled, and we don't really care about the result.\n" +
        '            // We can simply exit.\n' +
        '            if (this.pendingPulls.length === 0) {\n' +
        '              return;\n' +
        '            }\n' +
        '            if (status === 0) {\n' +
        '              // EOS\n' +
        '              c.close();\n' +
        '              // This is to signal the end for byob readers\n' +
        '              // see https://streams.spec.whatwg.org/#example-rbs-pull\n' +
        '              c.byobRequest?.respond(0);\n' +
        '              const pending = this.pendingPulls.shift();\n' +
        '              pending.resolve();\n' +
        '              return;\n' +
        '            } else if (status < 0) {\n' +
        '              // The read could fail for many different reasons when reading\n' +
        '              // from a non-memory resident blob part (e.g. file-backed blob).\n' +
        '              // The error details the system error code.\n' +
        "              const error = lazyDOMException('The blob could not be read', 'NotReadableError');\n" +
        '              const pending = this.pendingPulls.shift();\n' +
        '              c.error(error);\n' +
        '              pending.reject(error);\n' +
        '              return;\n' +
        '            }\n' +
        '            // ReadableByteStreamController.enqueue errors if we submit a 0-length\n' +
        '            // buffer. We need to check for that here.\n' +
        '            if (buffer !== undefined && buffer.byteLength !== 0) {\n' +
        '              c.enqueue(new Uint8Array(buffer));\n' +
        '            }\n' +
        '            // We keep reading until we either reach EOS, some error, or we\n' +
        '            // hit the flow rate of the stream (c.desiredSize).\n' +
        '            queueMicrotask(() => {\n' +
        '              if (c.desiredSize < 0) {\n' +
        '                // A manual backpressure check.\n' +
        '                if (this.pendingPulls.length !== 0) {\n' +
        '                  // A case of waiting pull finished (= not yet canceled)\n' +
        '                  const pending = this.pendingPulls.shift();\n' +
        '                  pending.resolve();\n' +
        '                }\n' +
        '                return;\n' +
        '              }\n' +
        '              readNext();\n' +
        '            });\n' +
        '          });\n' +
        '        };\n' +
        '        readNext();\n' +
        '        return promise;\n' +
        '      },\n' +
        '      cancel(reason) {\n' +
        '        // Reject any currently pending pulls here.\n' +
        '        for (const pending of this.pendingPulls) {\n' +
        '          pending.reject(reason);\n' +
        '        }\n' +
        '        this.pendingPulls = [];\n' +
        '      },\n' +
        '    // We set the highWaterMark to 0 because we do not want the stream to\n' +
        '    // start reading immediately on creation. We want it to wait until read\n' +
        '    // is called.\n' +
        '    }, new CountQueuingStrategy({ highWaterMark: 0 }));\n' +
        '  }\n' +
        '}'
    },
    validateStatus: '[function] function validateStatus(status) {\n' +
      '    return status >= 200 && status < 300;\n' +
      '  }',
    headers: {
      Accept: 'application/json, text/plain, */*',
      'Content-Type': 'application/x-www-form-urlencoded',
      'User-Agent': 'Hydra Launcher v3.7.5',
      Authorization: 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiJONVBuVlg0eSIsInNlc3Npb25JZCI6Ik9qYVhCZFlRIiwic2NvcGUiOlsiKiJdLCJpYXQiOjE3NjUxNzU2NTEsImV4cCI6MTc2NTE3OTI1MX0._YKhPqs8RS4x5j07oU48SOdgiIsAaEJJLr8GXOKJNzk',
      'Accept-Encoding': 'gzip, compress, deflate, br'
    },
    baseURL: 'https://hydra-api-us-east-1.losbroxas.org',
    method: 'post',
    url: '/auth/ws',
    allowAbsoluteUrls: true
  },
  code: 'ETIMEDOUT'
}
[2025-12-14 16:45:56.004] [error] (main)         Error on getSteamAppDetails { message: 'read ECONNRESET', code: 'ECONNRESET', name: 'Error' }
[2025-12-14 16:45:56.834] [error] (main)         Error on getSteamAppDetails { message: 'read ECONNRESET', code: 'ECONNRESET', name: 'Error' }
[2025-12-14 16:45:58.950] [error] (main)         Error on getSteamAppDetails { message: 'read ECONNRESET', code: 'ECONNRESET', name: 'Error' }
[2025-12-14 16:45:58.951] [error] (main)         Error on getSteamAppDetails { message: 'read ECONNRESET', code: 'ECONNRESET', name: 'Error' }
[2025-12-14 16:46:00.356] [error] (main)         Error on getSteamAppDetails { message: 'read ECONNRESET', code: 'ECONNRESET', name: 'Error' }
[2025-12-14 16:46:00.996] [error] (main)         Error on getSteamAppDetails { message: 'read ECONNRESET', code: 'ECONNRESET', name: 'Error' }
[2025-12-14 16:46:08.676] [error] (main)         Error on getSteamAppDetails { message: 'read ECONNRESET', code: 'ECONNRESET', name: 'Error' }
[2025-12-14 16:46:52.196] [error] (main)         Error on getSteamAppDetails { message: 'read ECONNRESET', code: 'ECONNRESET', name: 'Error' }
[2025-12-14 16:46:56.291] [error] (main)         Error on getSteamAppDetails { message: 'read ECONNRESET', code: 'ECONNRESET', name: 'Error' }
[2025-12-14 16:47:04.483] [error] (main)         Error on getSteamAppDetails { message: 'read ECONNRESET', code: 'ECONNRESET', name: 'Error' }
[2025-12-14 16:47:04.484] [error] (main)         Error on getSteamAppDetails { message: 'read ECONNRESET', code: 'ECONNRESET', name: 'Error' }
[2025-12-14 16:47:04.484] [error] (main)         Error on getSteamAppDetails { message: 'read ECONNRESET', code: 'ECONNRESET', name: 'Error' }
[2025-12-14 16:48:59.174] [error] (main)         Error on getSteamAppDetails { message: 'read ECONNRESET', code: 'ECONNRESET', name: 'Error' }
[2025-12-14 16:49:03.404] [error] (main)         Error on getSteamAppDetails { message: 'read ECONNRESET', code: 'ECONNRESET', name: 'Error' }
[2025-12-14 16:49:07.363] [error] (main)         Error on getSteamAppDetails { message: 'read ECONNRESET', code: 'ECONNRESET', name: 'Error' }
[2025-12-14 16:49:12.997] [error] (main)         Error on getSteamAppDetails { message: 'read ECONNRESET', code: 'ECONNRESET', name: 'Error' }
[2025-12-14 16:49:13.507] [error] (main)         Error on getSteamAppDetails { message: 'read ECONNRESET', code: 'ECONNRESET', name: 'Error' }
[2025-12-14 16:49:24.581] [error] (main)         Error on getSteamAppDetails { message: 'read ECONNRESET', code: 'ECONNRESET', name: 'Error' }
[2025-12-14 16:50:00.612] [error] (main)         Error on getSteamAppDetails { message: 'read ECONNRESET', code: 'ECONNRESET', name: 'Error' }
[2025-12-14 16:50:14.920] [error] (main)         Error on getSteamAppDetails { message: 'read ETIMEDOUT', code: 'ETIMEDOUT', name: 'Error' }
[2025-12-14 16:50:14.921] [error] (main)         Error on getSteamAppDetails { message: 'read ETIMEDOUT', code: 'ETIMEDOUT', name: 'Error' }
[2025-12-14 16:50:35.401] [error] (main)         Error on getSteamAppDetails { message: 'read ETIMEDOUT', code: 'ETIMEDOUT', name: 'Error' }
